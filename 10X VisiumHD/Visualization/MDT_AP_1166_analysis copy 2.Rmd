---
title: "Visium HD Analysis"
author: "Ricardo Gonzalez"
date: "`r Sys.Date()`"
output: html_document
---

# Load Libraries
We load the libraries necessary for processing scRNAseq data.
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(Seurat)
library(ggplot2)
library(patchwork)
library(dplyr)
library(ape)
library(SeuratWrappers)
library(Banksy)
library(harmony)
library(hdf5r)
library(BPCells)
library(MAST)
library(clustree)




```

# Load Visium HD data & Create Seurat Object

    The Seurat can store multiple binnings/resolutions in different assays
    bin.size parameter specifies resolutions to load (8 and 16um are loaded by default)
    Users can switch between resolutions by changing the assay

The Seurat package provides a function `Load10X_Spatial` to easily create a Seurat object from the output of Space Ranger.

    In the Visium HD assay, the barcodes are patterned in a continuous grid of 2x2 µm squares.
    By default, the SpaceRanger pipeline creates 8x8 µm and 16x16 µm bins of gene expression data. 
    
```{r create object}

localdir <- '/Users/ricardodgonzalez/Desktop/10X Genomics/April_14_2025/Outputs/MDT_AP_1166_spaceranger/outs'

# to load raw feature matrix
object <- Load10X_Spatial(data.dir = localdir, bin.size =8)
# Setting default assay changes between 8um and 16um binning
Assays(object)
DefaultAssay(object) <- "Spatial.008um"
head(object@meta.data)

```



# Quality Control (QC) to remove bins with low Unique Molecular Identifier (UMI) counts.

Plotting the distribution of UMI counts per 8µm bin in a histogram. 

    This visualization aids in determining a lower cutoff for transcript counts, specifically targeting the removal of     bins with low UMIs.

The precise determination of this lower cutoff can be subjective, as no universally applicable standard exists. 

    The objective is to remove low-quality bins and those likely not associated with tissue. 

Identifying the optimal lower cutoff often involves empirical testing and visual assessment of the bins overlaid on your tissue image.
```{r}
vln.plot <- VlnPlot(object, features = "nCount_Spatial.008um", pt.size = 0) + theme(axis.text = element_text(size = 4)) + NoLegend()
count.plot <- SpatialFeaturePlot(object, features = "nCount_Spatial.008um") + theme(legend.position = "right")

# note that many spots have very few counts, in-part
# due to low cellular density in certain tissue regions
vln.plot | count.plot


# Save TIFF
ggsave(file = "/Users/ricardodgonzalez/Desktop/10X Genomics/April_14_2025/Analysis/1166/Images/1166_countplot.tiff",
       plot = count.plot, device = "tiff", type = "cairo",
       width = 8, height = 10, units = "in",
       dpi = 300, compression = "lzw")
# Save TIFF
ggsave(file = "/Users/ricardodgonzalez/Desktop/10X Genomics/April_14_2025/Analysis/1166/Images/1166_vlnplot.tiff",
       plot = vln.plot, device = "tiff", type = "cairo",
       width = 8, height = 10, units = "in",
       dpi = 300, compression = "lzw")

hist(object$nCount_Spatial.008um, xlim = c(0, 1000), breaks = 5000) # if this metadata exists
abline(v = 40)
hist(object$nCount_Spatial.008um, xlim = c(0, 200), breaks = 5000) # if this metadata exists
abline(v = 40)
```

UMI Filtering: Your original nCount_Spatial.008um-based filtering.

Gene Filtering: Remove genes found in fewer than 3 bins.

Cell/Bin Filtering: Remove bins with fewer than 200 detected genes.

```{r}
## QC filtering bin based on detected UMIs per bin
## Upper limit cutoff - 98th percentile
## Lower limit cutoff - 40

# 1. UMI filtering (already in your code)
thres <- quantile(object$nCount_Spatial.008um, 0.98, na.rm = TRUE)
object <- subset(object, subset = nCount_Spatial.008um > 100 & nCount_Spatial.008um < thres)

# 2. Gene filtering: keep genes detected in >= 3 bins
detected_counts <- Matrix::rowSums(GetAssayData(object, slot = "counts") > 0)
genes_to_keep <- names(detected_counts[detected_counts >= 3])
object <- subset(object, features = genes_to_keep)

# 3. Bin filtering: keep bins with >= 100 detected genes
genes_per_bin <- Matrix::colSums(GetAssayData(object, slot = "counts") > 0)
object$nFeature_RNA <- genes_per_bin
object <- subset(object, subset = nFeature_RNA >= 100)

hist(object$nFeature_RNA, main = "Detected Genes per Bin", xlab = "Number of Genes")
abline(v = 100, col = "red", lwd = 2)

vln.plot_qc <- VlnPlot(object, features = "nCount_Spatial.008um", pt.size = 0) + theme(axis.text = element_text(size = 4)) + NoLegend()
count.plot_qc <- SpatialFeaturePlot(object, features = "nCount_Spatial.008um") + theme(legend.position = "right")

vln.plot_qc | count.plot_qc


#saveRDS(object, file = "/Users/ricardodgonzalez/Desktop/10X\ Genomics/April_14_2025/Analysis/QC_filtered_object_MDTAP1166.rds")
# Save TIFF
ggsave(file = "/Users/ricardodgonzalez/Desktop/10X Genomics/April_14_2025/Analysis/1166/Images/1166_countplot_qc.tiff",
       plot = count.plot_qc, device = "tiff", type = "cairo",
       width = 8, height = 10, units = "in",
       dpi = 300, compression = "lzw")
ggsave(file = "/Users/ricardodgonzalez/Desktop/10X Genomics/April_14_2025/Analysis/1166/Images/1166_vln_plot_qc.tiff",
      plot = vln.plot_qc, device = "tiff", type = "cairo",
      width = 8, height = 10, units = "in",
     dpi = 300, compression = "lzw")
#Post QC Histogram and Bins counts* 
  
hist(object$nCount_Spatial.008um, xlim = c(0, 1000), breaks = 5000) # if this metadata exists
abline(v = 100)

n_bins <- ncol(object)
print(n_bins)

```







# Normalize datasets & Top variable genes to be used for principal component analysis (PCA) later on.
    use standard log-normalization for spatial data. 
    We note that the best normalization methods for spatial data are still being developed and evaluated, 
    and encourage users to read manuscripts to learn more about potential caveats for spatial normalization.
    
*in HPC*

```{r}

# normalize both 8um and 16um bins in HPC, Not enough RAM on Local for :object <- SCTransform(object,assay = "Spatial.008um")
DefaultAssay(object) <- "Spatial.008um"
# normalize our data using median transcript count as the scale factor to normalize based on library size.
object<- NormalizeData(object,scale.factor=median(object$nCount_Spatial.008um))

## Find top 2k variable genes
object <- FindVariableFeatures(object)

```



# Unsupervised clustering- Conventional data processing

When working with Visium HD datasets, the Seurat v5 sketch clustering workflow exhibits improved performance, 
especially for identifying rare and spatially restricted groups.

    As described in Hao et al, Nature Biotechnology 2023 and Hie et al, 
    sketch-based analyses aim to ‘subsample’ large datasets in a way that preserves rare populations. 
    
Here, we sketch the Visium HD dataset, perform clustering on the subsampled cells, 
and then project the cluster labels back to the full dataset.

*Subsample (sketch) bins from all bins - Data are more manageable*

We will downsample both of our samples to 50,000 bins.  

      You will need to consider how many bins you have for each sample and 
      how many would still be representative of the entire dataset when deciding on the downsample number.

```{r}
# note that data is already normalized
DefaultAssay(object) <- "Spatial.008um"

# we select 50,0000 cells and create a new 'sketch' assay
object <- SketchData(
  object = object,
  ncells = 50000,
  assay = "Spatial.008um",
  method = "LeverageScore",
  sketched.assay = "sketch",
  features = VariableFeatures(object)
)

```


*conventional data processing*
    which includes: find variable genes, data scaling, and Principal Component Analysis (PCA).
```{r}
# switch analysis to sketched cells
DefaultAssay(object) <- "sketch"

# perform clustering workflow
object <- FindVariableFeatures(object)
object <- ScaleData(object)
object <- RunPCA(object, assay = "sketch", reduction.name = "pca.sketch")

```

# JackStraw and Analysis Optimization (Dims,Resolution,Clustree )
Assumes you have already run PCA on your Seurat object (object) using your desired assay (e.g., "sketch") and reduction name ("pca.sketch").
```{r}
# You may need to run PCA first if not already done:***should be done in chunk above***

# Run JackStraw analysis
object <- JackStraw(
  object,
  dims = 30,
  num.replicate = 100,
  assay = "sketch")


```

Plot JackStraw Results & Elbow Plot Analysis
  ***Choose Number of Dims***
  
    1.Examine both plots together.
    2.Retain PCs up to the point where JackStraw p-values are significant and 
      before the elbow point (variance drops off).
    3.E.g., if PCs 1–19 are significant, use dims = 1:19 for downstream steps:

```{r}
# Compute significance for each PC
object <- ScoreJackStraw(object, dims = 1:30)


JackStrawPlot(object, dims = 1:30)
# The plot shows, for each PC, a QQ-plot of observed vs. null p-values. PCs with a significant "tail" of low p-values are likely to capture significant structure.
# Retain those with strong evidence of significance (see where the plot transitions from significant to background-like).

ElbowPlot(object, ndims = 30)
# shows the percent variance explained per PC—use in combination with JackStraw:
# Look for the “elbow” where additional PCs contribute little extra variance; often coincides with the tail-off of JackStraw significance
```

***Choose Number of Dims***
```{r}
object <- FindNeighbors(object, assay = "sketch", reduction = "pca.sketch", dims = 1:20)
```

Try Multiple Resolution Values
  *Record Number of Clusters at Each Resolution*
  **Visualize Clusters**
  ***Biological Interpretability***

```{r}
#1.Test a range of resolutions (e.g., 0.2, 0.4, 0.6, 0.8, 1, 1.5, 2, 3) and examine clustering results
resolutions <- seq(0.5, 3, by=0.5)
for (res in resolutions) {
  object <- FindClusters(
    object,
    resolution = res,
    algorithm = 1, # or whichever you use,
    cluster.name = paste0("clusters_", res)
  )
}
#2.This helps visualize how many clusters form at each resolution.

num_clusters <- sapply(resolutions, function(res) {
  col <- paste0("clusters_", res)
  length(unique(object@meta.data[[col]]))
})
plot(resolutions, num_clusters, type="b", xlab="Resolution", ylab="Number of clusters")

#3.Plot UMAPs/tSNEs colored by different clusterings. For example, for resolution = 1:
#Compare how clusters map onto the underlying data and known markers.
DimPlot(object, group.by = "clusters_1")
DimPlot(object, group.by = "clusters_2")

#4.For each resolution, check if clusters correspond to expected cell populations (using markers or annotation tools).
#Over-clustering splits known populations, under-clustering merges distinct groups.

```

Clustree: Visualize Cluster Merging/Splitting
  *Stability of Clusters* Stable clusters: If a group of cells is assigned to the same cluster across multiple resolutions, 
                                            you’ll see a vertical path through the plot, 
                                            with edges staying together across resolutions.

                           Unstable clusters: If a cluster frequently splits or merges as you change resolution, 
                                              it may not represent a robust biological population.
                        
  *Choosing the Best Resolution* Biological reasoning: Look for a resolution before large, 
                                                        stable clusters begin to split into very small sub-clusters or 
                                                        when previously distinct clusters merge together.

                                  Overclustering: At very high resolutions, clusters may split excessively, 
                                                  dividing meaningful populations into tiny groups.

                                  Underclustering: At low resolutions, clusters merge, potentially grouping
                                                   distinct cell types together and reducing biological interpretability.

  *Transition Points* Clusters that persist across several resolutions are strong candidates 
                      for cell populations worth interrogating.
                      
                      The point where clusters begin to split rapidly is usually regarded as 
                      the upper limit for useful resolution.

                      The point before several large clusters merge is the lower limit.
    
*Select a resolution where clusters are stable across levels and correspond to known biological types (using additional marker/annotation analysis).*
*Avoid resolutions where clusters fragment or merge dramatically unless you have strong biological justification.*
*Use clustree in combination with marker gene analysis and visualization of cluster distributions on UMAP/tSNE plots for most robust interpretation.*
    
```{r}
#5.
# Show columns that match the prefix
cluster_cols <- grep("^clusters_", colnames(object@meta.data), value = TRUE)
# Check for NA in any of those columns
na_rows <- which(rowSums(is.na(object@meta.data[, cluster_cols])) > 0)
length(na_rows) # How many problematic rows?
# Optionally, view one
object@meta.data[na_rows[1], cluster_cols]

# Retain only rows where all clusters_* columns are not NA
meta_clean <- object@meta.data[complete.cases(object@meta.data[, cluster_cols]), ]
# Use with clustree:
clustree(meta_clean, prefix = "clusters_")

```

```{r}
# Use clustree but only on 'clusters_2' and 'clusters_3' columns from meta_clean
clustree(meta_clean[, c("clusters_0.5", "clusters_1", "clusters_1.5")], prefix = "clusters_")
```

***Choose Number of Res***

```{r}
object <- FindClusters(object, cluster.name = "seurat_cluster.sketched", resolution = 1)
object <- RunUMAP(object, reduction = "pca.sketch", reduction.name = "umap.sketch", return.model = T, dims = 1:20)
```

# Project results from "sketch" 50k bins to all bins
Now we can project the cluster labels, and dimensional reductions (PCA and UMAP) that we learned from the 50,000 sketched cells - to the entire dataset, using the ProjectData function.


```{r}
object <- ProjectData(
  object = object,
  assay = "Spatial.008um",
  full.reduction = "full.pca.sketch",
  sketched.assay = "sketch",
  sketched.reduction = "pca.sketch",
  umap.model = "umap.sketch",
  dims = 1:20,
  refdata = list(seurat_cluster.projected = "seurat_cluster.sketched")
)
```


#Identifying spatially-defined tissue domains
While the previous analyses consider each bin independently, spatial data enables cells to be defined not just by their neighborhood, but also by their broader spatial context.

In Singhal et al., the authors introduce BANKSY, Building Aggregates with a Neighborhood Kernel and Spatial Yardstick (BANKSY). BANKSY performs multiple tasks, but we find it particularly valuable for identifying and segmenting tissue domains. When performing clustering, BANKSY augments a spot’s expression pattern with both the mean and the gradient of gene expression levels in a spot’s broader neighborhood.

We thank the authors for enabling BANKSY to be compatible with Seurat via the SeuratWrappers framework, which requires separate installation of the BANKSY package:

```{r}
object <- RunBanksy(
  object,
  lambda = 0.8, # example value
  assay = "Spatial.008um", # or "Spatial.008um" or whatever your source assay is
  slot = "data",
  features = "variable", # or "all"
  k_geom = 15,
  k_spatial = 10,
  assay_name = "BANKSY",
  verbose = TRUE
)

DefaultAssay(object) <- "BANKSY"
object <- RunPCA(object, assay = "BANKSY", reduction.name = "pca.banksy", features = rownames(object), npcs = 30)
object <- FindNeighbors(object, reduction = "pca.banksy", dims = 1:30)
object <- FindClusters(object, cluster.name = "banksy_cluster", resolution = 0.5)
object <- RunUMAP(object, reduction = "pca.banksy", reduction.name = "umap.banksy", return.model = T, dims = 1:30)
```


#Annotations
```{r}
# load in the reference scRNA-seq dataset
library(spacexr)
ref <- readRDS("/Users/ricardodgonzalez/Desktop/10X Genomics/G3_MB.rds")

Assays(ref)
head(ref@meta.data)
Idents(ref) <- "annotated.clusters"
counts <- ref[["SCT"]]@counts

cluster <- as.factor(ref$annotated.clusters)
nUMI <- ref$nCount_RNA
levels(cluster) <- gsub("/", "-", levels(cluster))
cluster <- droplevels(cluster)
# create the RCTD reference object
reference <- Reference(counts, cluster, nUMI)

counts_hd <- object[["sketch"]]$counts
object_cells_hd <- colnames(object[["sketch"]])
coords <- GetTissueCoordinates(object)[object_cells_hd, 1:2]
# create the RCTD query object
query <- SpatialRNA(coords, counts_hd, colSums(counts_hd))

# run RCTD
RCTD <- create.RCTD(query, reference, max_cores = 12)
RCTD <- run.RCTD(RCTD, doublet_mode = "doublet")
# add results back to Seurat object
object <- AddMetaData(object, metadata = RCTD@results$results_df)


```

This step is necessary because RCTD was run only on the sketch assay, which has a reduced subset of cells and their PCA/UMAP embeddings. The projection helps predict or assign these annotations to the full dataset based on the learned relationships in the reduced sketch.
```{r}

# project RCTD labels from sketched cells to all cells
# Prepare first_type
object$first_type <- as.character(object$first_type)
object$first_type[is.na(object$first_type)] <- "Unknown"
# Prepare second_type
object$second_type <- as.character(object$second_type)
object$second_type[is.na(object$second_type)] <- "Unknown"


object <- ProjectData(
  object = object,
  assay = "Spatial.008um",
  full.reduction = "full.pca.sketch",
  sketched.assay = "sketch",
  sketched.reduction = "pca.sketch",
  umap.model = "umap.sketch",
  dims = 1:20,
  refdata = list(full_first_type = "first_type", full_second_type = "second_type")
)



object <- ProjectData(
  object = object,
  assay = "BANKSY",           # target assay where you want the projected labels
  full.reduction = "pca.banksy",
  sketched.assay = "sketch",  # reference assay where RCTD labels exist
  sketched.reduction = "pca.sketch",
  umap.model = "umap.sketch",
  dims = 1:20,
  refdata = list(full_first_type_banksy = "first_type", full_second_type_banksy = "second_type")
)

```







#Visualization
#####################################################Visualization##################################################### 
    ################################################*Pre_Annotations*################################################ 

```{r}
#object <- readRDS("/Users/ricardodgonzalez/Desktop/10X Genomics/April_14_2025/Analysis/1166/SeuratObjects/qc_sketch_banksy_mdtap1166.rds")
object<- readRDS("/Users/ricardodgonzalez/Desktop/10X Genomics/April_14_2025/Analysis/1166/SeuratObjects/G3Annotations_qc_sketch_banksy_RCTD_Projections_mdtap1166.rds")
```


We can visualize the clustering results for the sketched cells, as well as the projected clustering results for the full dataset:
```{r}
DefaultAssay(object) <- "sketch"
Idents(object) <- "seurat_cluster.sketched"
p1 <- DimPlot(object, reduction = "umap.sketch", label = F) + ggtitle("Sketched clustering (50,000 cells)") + theme(legend.position = "right")

# switch to full dataset
DefaultAssay(object) <- "Spatial.008um"
Idents(object) <- "seurat_cluster.projected"
p2 <- DimPlot(object, reduction = "full.umap.sketch", label = F) + ggtitle("Projected clustering (full dataset)") + theme(legend.position = "right")


DefaultAssay(object) <- "BANKSY"
Idents(object) <- "banksy_cluster"
p3 <- DimPlot(object, reduction = "umap.banksy", label = FALSE) + 
  ggtitle("BANKSY (Spatially-informed Clustering)") + 
  theme(legend.position = "right")

p2| p3
```




Of course, we can now also visualize the unsupervised clusters based on their spatial location. Note that running SpatialDimPlot(object, interactive = TRUE), also enables interactive visualization and exploration.
When there are many different clusters (some of which are spatially restricted and others are mixed), plotting the spatial location of all clusters can be challenging to interpret. We find it helpful to plot the spatial location of different clusters individually. For example, we highlight the spatial localization of a few clusters below, which happen to correspond to different cortical layers:

```{r}

DefaultAssay(object) <- "sketch"
Idents(object) <- "seurat_cluster.sketched"
p4 <- SpatialDimPlot(object,  label = F) + ggtitle("Sketched clustering (50,000 cells)") + theme(legend.position = "right")

# Get cells by cluster identity excluding "NA"
cells_sketch <- CellsByIdentities(object)
cells_sketch <- cells_sketch[setdiff(names(cells_sketch), "NA")]
# Create SpatialDimPlot with highlighted clusters faceted
p5 <- SpatialDimPlot(object,
                           cells.highlight = cells_sketch,
                           cols.highlight = c("#FFFF00", "grey50"),
                           facet.highlight = TRUE,
                           combine = TRUE) + 
            NoLegend() + 
            ggtitle("Sketch clustering (highlighted)")



# Set assay and identities to the projected clustering
# switch to full dataset
DefaultAssay(object) <- "Spatial.008um"
Idents(object) <- "seurat_cluster.projected"
p6 <- SpatialDimPlot(object, label = F) + ggtitle("Projected clustering (full dataset)") + theme(legend.position = "right")
# Get cells by cluster identity, excluding any "NA" if present
cells_proj <- CellsByIdentities(object)
cells_proj <- cells_proj[setdiff(names(cells_proj), "NA")]
# Create SpatialDimPlot highlighting all clusters faceted by cluster (like your original p)
p7 <- SpatialDimPlot(object,
                         cells.highlight = cells_proj,
                         cols.highlight = c("#FFFF00", "grey50"),
                         facet.highlight = TRUE,
                         combine = TRUE) + 
          NoLegend() + 
          ggtitle("Projected clustering (highlighted)")


# Set assay and identities to the banksy clustering
DefaultAssay(object) <- "BANKSY"
Idents(object) <- "banksy_cluster"
p8 <- SpatialDimPlot(object,label = F) + ggtitle("BANKSY (Spatially-informed Clustering)") + theme(legend.position = "right")
# Get cells by cluster identity excluding "NA"
cells_banksy <- CellsByIdentities(object)
cells_banksy <- cells_banksy[setdiff(names(cells_banksy), "NA")]

# Create SpatialDimPlot with highlighted clusters faceted
p9 <- SpatialDimPlot(object,
                           cells.highlight = cells_banksy,
                           cols.highlight = c("#FFFF00", "grey50"),
                           facet.highlight = TRUE,
                           combine = TRUE) + 
            NoLegend() + 
            ggtitle("BANKSY clustering (highlighted)")
p4
p6
p8
```


# Find cluster marker genes for cell annotation

We can compute marker genes for each cluster to facilitate cluster annotation. For this analysis, we will again use the sketch assay within the Seurat object.


We can also find and visualize the top gene expression markers for each cluster:

```{r}
# For Spatial.008um assay
DefaultAssay(object) <- "Spatial.008um"
Idents(object) <- "seurat_cluster.projected"
object_subset <- subset(object, cells = Cells(object[["Spatial.008um"]]), downsample = 1000)
object_subset <- BuildClusterTree(object_subset, assay = "Spatial.008um", reduction = "full.pca.sketch", reorder = TRUE)
p10 <- PlotClusterTree(object_subset)
# For BANKSY assay
DefaultAssay(object) <- "Spatial.008um"
Idents(object) <- "banksy_cluster"
object_subset <- subset(object, cells = Cells(object[["Spatial.008um"]]), downsample = 1000)
object_subset <- BuildClusterTree(object_subset, assay = "Spatial.008um", reduction = "full.pca.sketch", reorder = TRUE)
p11 <- PlotClusterTree(object_subset)

# Later load them back as needed
#object_subset <- readRDS("/Users/ricardodgonzalez/Desktop/10X Genomics/April_14_2025/Analysis/1166/SeuratObjects/object_subset_projected_banksy_downsampled.rds")

```


```{r}

# For Projected clustering using the downsampled subset
DefaultAssay(object_subset) <- "Spatial.008um"
Idents(object_subset) <- "seurat_cluster.projected"

markers_projected <- FindAllMarkers(
  object = object_subset,
  assay = "Spatial.008um",
  only.pos = TRUE,
  test.use = "MAST",
  logfc.threshold = 0.25,
  min.pct = 0.1
)
# Filter markers with adjusted p-value < 0.05
significant_markers_proj <- markers_projected %>% filter(p_val_adj < 0.05)

# Save top 5 markers per cluster
top5_proj <- significant_markers_proj %>%
  group_by(cluster) %>%
  slice_min(order_by = p_val_adj, n = 5) %>%
  ungroup()
# Save top 25 markers per cluster
top25_proj <- significant_markers_proj %>%
  group_by(cluster) %>%
  slice_min(order_by = p_val_adj, n = 25) %>%
  ungroup()
# Heatmap of top 10 markers (log2FC > 1) for visualization
top10_proj <- significant_markers_proj %>%
  filter(avg_log2FC > 1) %>%
  group_by(cluster) %>%
  slice_min(order_by = p_val_adj, n = 10) %>%
  ungroup()

# Filter significant markers, top 5, top 25, etc. same as before on object_subset
# Scaling and heatmap on object_subset
object_subset <- ScaleData(object_subset, assay = "Spatial.008um", features = top10_proj$gene)
p12<- DoHeatmap(object_subset, assay = "Spatial.008um", features = unique(top10_proj$gene), size = 2.5) +
  theme(axis.text = element_text(size = 5.5)) + NoLegend() +
  ggtitle("Projected clustering top markers (MAST)")


# --- For Banksy clustering in 'object' ---
# For Banksy clustering using the downsampled subset
DefaultAssay(object_subset) <- "Spatial.008um"
Idents(object_subset) <- "banksy_cluster"

markers_banksy <- FindAllMarkers(
  object = object_subset,
  assay = "Spatial.008um",
  only.pos = TRUE,
  test.use = "MAST",
  logfc.threshold = 0.25,
  min.pct = 0.1
)
# Filter markers with adjusted p-value < 0.05
significant_markers_banksy <- markers_banksy %>% filter(p_val_adj < 0.05)

# Save top 5 markers per cluster
top5_banksy <- significant_markers_banksy %>%
  group_by(cluster) %>%
  slice_min(order_by = p_val_adj, n = 5) %>%
  ungroup()
# Save top 25 markers per cluster
top25_banksy <- significant_markers_banksy %>%
  group_by(cluster) %>%
  slice_min(order_by = p_val_adj, n = 25) %>%
  ungroup()
# Heatmap of top 10 markers (log2FC > 1) for visualization
top10_banksy <- significant_markers_banksy %>%
  filter(avg_log2FC > 1) %>%
  group_by(cluster) %>%
  slice_min(order_by = p_val_adj, n = 10) %>%
  ungroup()

# Similarly filter and save markers with object_subset
object_subset <- ScaleData(object_subset, assay = "Spatial.008um", features = top10_banksy$gene)
p13<- DoHeatmap(object_subset, assay = "Spatial.008um", features = unique(top10_banksy$gene), size = 2.5) +
  theme(axis.text = element_text(size = 5.5)) + NoLegend() +
  ggtitle("Banksy clustering top markers (MAST)")


```



```{r}



# Save subset objects with informative names
#saveRDS(object_subset, file = "/Users/ricardodgonzalez/Desktop/10X Genomics/April_14_2025/Analysis/1166/SeuratObjects/object_subset_projected_banksy_downsampled.rds")


write.csv(top5_proj,
          file = "/Users/ricardodgonzalez/Desktop/10X Genomics/April_14_2025/Analysis/1166/top5_projected_markers.csv",
          row.names = FALSE, quote = FALSE)
write.csv(top10_proj,
          file = "/Users/ricardodgonzalez/Desktop/10X Genomics/April_14_2025/Analysis/1166/top10_projected_markers.csv",
          row.names = FALSE, quote = FALSE)
write.csv(top25_proj,
          file = "/Users/ricardodgonzalez/Desktop/10X Genomics/April_14_2025/Analysis/1166/top25_projected_markers.csv",
          row.names = FALSE, quote = FALSE)

write.csv(top5_banksy,
          file = "/Users/ricardodgonzalez/Desktop/10X Genomics/April_14_2025/Analysis/1166/top5_banksy_markers.csv",
          row.names = FALSE, quote = FALSE)
write.csv(top10_banksy,
          file = "/Users/ricardodgonzalez/Desktop/10X Genomics/April_14_2025/Analysis/1166/top10_banksy_markers.csv",
          row.names = FALSE, quote = FALSE)
write.csv(top25_banksy,
          file = "/Users/ricardodgonzalez/Desktop/10X Genomics/April_14_2025/Analysis/1166/top25_banksy_markers.csv",
          row.names = FALSE, quote = FALSE)
```


#####################################################*Visualization*##################################################### 
    ###################################################*Annotated*################################################### 



Annotations
```{r}
object<- readRDS("/Users/ricardodgonzalez/Desktop/10X Genomics/April_14_2025/Analysis/1166/SeuratObjects/G3Annotations_qc_sketch_banksy_RCTD_Projections_mdtap1166.rds")
```


```{r}
# Annotated RCTD plots starting at p13

# Annotated first_type on full.umap.sketch (p13)
Idents(object) <- "full_first_type"
p14 <- DimPlot(object, reduction = "full.umap.sketch", label = FALSE) +
  ggtitle("G3 Annotated on full.umap.sketch") +
  theme(legend.position = "right")

# Annotated second_type on full.umap.sketch (p14)
Idents(object) <- "full_second_type"
p15 <- DimPlot(object, reduction = "full.umap.sketch", label = FALSE) +
  ggtitle("G3 Annotated (second_type, RCTD projected) on full.umap.sketch") +
  theme(legend.position = "right")

# Annotated first_type on BANKSY projection (p15)
Idents(object) <- "full_first_type_banksy"
p16 <- DimPlot(object, reduction = "umap.banksy", label = FALSE) +
  ggtitle("G3 Annotated on BANKSY") +
  theme(legend.position = "right")

# Annotated second_type on BANKSY projection (p16)
Idents(object) <- "full_second_type_banksy"
p17 <- DimPlot(object, reduction = "umap.banksy", label = FALSE) +
  ggtitle("G3 Annotated (second_type_banksy, RCTD projected) on BANKSY") +
  theme(legend.position = "right")


```



```{r}
DefaultAssay(object) <- "sketch"
Idents(object) <- "full_first_type"
p18 <- SpatialDimPlot(object,cols = color_vector,  label = F) + ggtitle("Sketched G3 annotations (50,000 cells)") + theme(legend.position = "right")

# Get cells by cluster identity excluding "NA"
cells_sketch_ann <- CellsByIdentities(object)
cells_sketch_ann <- cells_sketch_ann[setdiff(names(cells_sketch_ann), "NA")]
# Create SpatialDimPlot with highlighted clusters faceted
p19 <- SpatialDimPlot(object,
                           cells.highlight = cells_sketch_ann,
                           cols.highlight = c("#FFFF00", "grey50"),
                           facet.highlight = TRUE,
                           combine = TRUE) + 
            NoLegend() + 
            ggtitle("G3 Annotated on Sketch spatial")


# Set assay and identities to the projected clustering
# switch to full dataset
DefaultAssay(object) <- "Spatial.008um"
Idents(object) <- "full_first_type"
p20 <- SpatialDimPlot(object, label = F,cols = color_vector) + ggtitle("Projected Annotations full dataset") + theme(legend.position = "right")
# Get cells by cluster identity, excluding any "NA" if present
cells_proj_ann <- CellsByIdentities(object)
cells_proj_ann <- cells_proj_ann[setdiff(names(cells_proj_ann), "NA")]
# Create SpatialDimPlot highlighting all clusters faceted by cluster (like your original p)
p21 <- SpatialDimPlot(object,
                         cells.highlight = cells_proj_ann,
                         cols.highlight = c("#FFFF00", "grey50"),
                         facet.highlight = TRUE,
                         combine = TRUE) + 
          NoLegend() + 
          ggtitle("G3 Annotated on Full spatial")



# Set assay and identities to the banksy clustering
DefaultAssay(object) <- "BANKSY"
Idents(object) <- "full_first_type_banksy"
p22 <- SpatialDimPlot(object,label = F,cols = color_vector) + ggtitle("BANKSY Spatially-informed G3 annotations") + theme(legend.position = "right")
# Get cells by cluster identity excluding "NA"
cells_banksy_ann <- CellsByIdentities(object)
cells_banksy_ann <- cells_banksy_ann[setdiff(names(cells_banksy_ann), "NA")]

# Create SpatialDimPlot with highlighted clusters faceted
p23 <- SpatialDimPlot(object,
                           cells.highlight = cells_banksy_ann,
                           cols.highlight = c("#FFFF00", "grey50"),
                           facet.highlight = TRUE,
                           combine = TRUE) + 
            NoLegend() + 
            ggtitle("G3 Annotated on BANKSY spatial")

```





```{r}
# Use assay and identities for the "full_second_type"
DefaultAssay(object) <- "sketch"
Idents(object) <- "full_second_type"
p24 <- SpatialDimPlot(object, label = F) + ggtitle("Sketched G3 annotations (full_second_type, 50,000 cells)") + theme(legend.position = "right")

# Get cells by cluster identity excluding "NA"
cells_sketch_ann_2 <- CellsByIdentities(object)
cells_sketch_ann_2 <- cells_sketch_ann_2[setdiff(names(cells_sketch_ann_2), "NA")]

# Create SpatialDimPlot with highlighted clusters faceted for second type
p25 <- SpatialDimPlot(object,
                     cells.highlight = cells_sketch_ann_2,
                     cols.highlight = c("#FFFF00", "grey50"),
                     facet.highlight = TRUE,
                     combine = TRUE) + 
        NoLegend() + 
        ggtitle("G3 Annotated on Sketch spatial (full_second_type)")

# Set assay and identities to the projected clustering for second type
DefaultAssay(object) <- "Spatial.008um"
Idents(object) <- "full_second_type"
p26 <- SpatialDimPlot(object, label = F) + ggtitle("Projected Annotations full dataset (full_second_type)") + theme(legend.position = "right")

# Get cells by cluster identity excluding "NA"
cells_proj_ann_2 <- CellsByIdentities(object)
cells_proj_ann_2 <- cells_proj_ann_2[setdiff(names(cells_proj_ann_2), "NA")]

# Create SpatialDimPlot highlighting all clusters faceted for second type
p27 <- SpatialDimPlot(object,
                     cells.highlight = cells_proj_ann_2,
                     cols.highlight = c("#FFFF00", "grey50"),
                     facet.highlight = TRUE,
                     combine = TRUE) + 
        NoLegend() + 
        ggtitle("G3 Annotated on Full spatial (full_second_type)")

# Set assay and identities to the banksy clustering for second type
DefaultAssay(object) <- "BANKSY"
Idents(object) <- "full_second_type_banksy"
p28 <- SpatialDimPlot(object, label = F,cols = color_vector) + ggtitle("BANKSY Spatially-informed G3 annotations (full_second_type_banksy)") + theme(legend.position = "right")

# Get cells by cluster identity excluding "NA"
cells_banksy_ann_2 <- CellsByIdentities(object)
cells_banksy_ann_2 <- cells_banksy_ann_2[setdiff(names(cells_banksy_ann_2), "NA")]

# Create SpatialDimPlot with highlighted clusters faceted for second type banksy
p29 <- SpatialDimPlot(object,
                     cells.highlight = cells_banksy_ann_2,
                     cols.highlight = c("#FFFF00", "grey50"),
                     facet.highlight = TRUE,
                     combine = TRUE) + 
        NoLegend() + 
        ggtitle("G3 Annotated on BANKSY spatial (full_second_type_banksy)")

# To display plots in sequence, call:



```




```{r}
# Set assay and identity for projected clusters
# For spatial projected clustering tree (p30)
DefaultAssay(object) <- "Spatial.008um"
Idents(object) <- "full_first_type"
object_subset <- subset(object, cells = Cells(object[["Spatial.008um"]]), downsample = 1000)
object_subset <- BuildClusterTree(object_subset, assay = "Spatial.008um", reduction = "full.pca.sketch", reorder = TRUE)
p30 <- PlotClusterTree(object_subset)

# For BANKSY clustering tree (p31)
DefaultAssay(object) <- "Spatial.008um"
Idents(object) <- "full_first_type_banksy"
object_subset <- subset(object, cells = Cells(object[["Spatial.008um"]]), downsample = 1000)
object_subset <- BuildClusterTree(object_subset, assay = "Spatial.008um", reduction = "full.pca.sketch", reorder = TRUE)
p31 <- PlotClusterTree(object_subset)

# Run marker detection on subset for 'full_first_type' clusters
DefaultAssay(object_subset) <- "Spatial.008um"
Idents(object_subset) <- "full_first_type"
markers_projected <- FindAllMarkers(
  object = object_subset,
  assay = "Spatial.008um",
  only.pos = TRUE,
  test.use = "MAST",
  logfc.threshold = 0.25,
  min.pct = 0.1
)
significant_markers_proj <- markers_projected %>% filter(p_val_adj < 0.05)
top10_proj <- significant_markers_proj %>%
  filter(avg_log2FC > 1) %>%
  group_by(cluster) %>%
  slice_min(order_by = p_val_adj, n = 10) %>%
  ungroup()

object_subset <- ScaleData(object_subset, assay = "Spatial.008um", features = top10_proj$gene)
p32 <- DoHeatmap(object_subset, assay = "Spatial.008um", features = unique(top10_proj$gene), size = 2.5) +
  theme(axis.text = element_text(size = 5.5)) + NoLegend() +
  ggtitle("Projected top markers (MAST)")

# Run marker detection on subset for 'full_first_type_banksy' clusters
DefaultAssay(object_subset) <- "Spatial.008um"
Idents(object_subset) <- "full_first_type_banksy"
markers_banksy <- FindAllMarkers(
  object = object_subset,
  assay = "Spatial.008um",
  only.pos = TRUE,
  test.use = "MAST",
  logfc.threshold = 0.25,
  min.pct = 0.1
)
significant_markers_banksy <- markers_banksy %>% filter(p_val_adj < 0.05)
top10_banksy <- significant_markers_banksy %>%
  filter(avg_log2FC > 1) %>%
  group_by(cluster) %>%
  slice_min(order_by = p_val_adj, n = 10) %>%
  ungroup()

object_subset <- ScaleData(object_subset, assay = "Spatial.008um", features = top10_banksy$gene)
p33 <- DoHeatmap(object_subset, assay = "Spatial.008um", features = unique(top10_banksy$gene), size = 2.5) +
  theme(axis.text = element_text(size = 5.5)) + NoLegend() +
  ggtitle("Banksy top markers (MAST)")

```









```{r}
# Create a list containing all your plots from p1 to p33
plots <- list(p1, p2, p3, p4, p5, p6, p7, p8, p9,
              p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23,
              p24, p25, p26, p27, p28, p29, p30, p31, p32, p33)

# Loop over plots and save each with a numbered filename
for (i in seq_along(plots)) {
  ggsave(filename = sprintf("/Users/ricardodgonzalez/Desktop/10X Genomics/April_14_2025/Analysis/1166/Images/1166_p%d.tiff", i),
         plot = plots[[i]], device = "tiff", type = "cairo",
         width = 12, height = 10, units = "in",
         dpi = 300, compression = "lzw")
}

     
   write.csv(top5_proj,
          file = "/Users/ricardodgonzalez/Desktop/10X Genomics/April_14_2025/Analysis/1166/top5_projected_markers_ann.csv",
          row.names = FALSE, quote = FALSE)
write.csv(top10_proj,
          file = "/Users/ricardodgonzalez/Desktop/10X Genomics/April_14_2025/Analysis/1166/top10_projected_markers_ann.csv",
          row.names = FALSE, quote = FALSE)
write.csv(top25_proj,
          file = "/Users/ricardodgonzalez/Desktop/10X Genomics/April_14_2025/Analysis/1166/top25_projected_markers_ann.csv",
          row.names = FALSE, quote = FALSE)

write.csv(top5_banksy,
          file = "/Users/ricardodgonzalez/Desktop/10X Genomics/April_14_2025/Analysis/1166/top5_banksy_markers_ann.csv",
          row.names = FALSE, quote = FALSE)
write.csv(top10_banksy,
          file = "/Users/ricardodgonzalez/Desktop/10X Genomics/April_14_2025/Analysis/1166/top10_banksy_markers_ann.csv",
          row.names = FALSE, quote = FALSE)
write.csv(top25_banksy,
          file = "/Users/ricardodgonzalez/Desktop/10X Genomics/April_14_2025/Analysis/1166/top25_banksy_markers_ann.csv",
          row.names = FALSE, quote = FALSE) 


# Save subset objects with informative names
#saveRDS(object_subset, file = "/Users/ricardodgonzalez/Desktop/10X Genomics/April_14_2025/Analysis/1166/SeuratObjects/object_subset_projected_banksy_downsampled.rds")

```

```{r}
DefaultAssay(object) <- "Spatial.008um"
Idents(object) <- "full_first_type"
vln.plot <- VlnPlot(object, features = "nCount_Spatial.008um", pt.size = 0) + theme(axis.text = element_text(size = 4)) + NoLegend()
count.plot <- SpatialFeaturePlot(object, features = "nCount_Spatial.008um") + theme(legend.position = "right")

vln.plot | count.plot


#saveRDS(object, file = "/Users/ricardodgonzalez/Desktop/10X\ Genomics/April_14_2025/Analysis/QC_filtered_object_MDTAP1166.rds")
# Save TIFF
ggsave(file = "/Users/ricardodgonzalez/Desktop/10X Genomics/April_14_2025/Analysis/1166/Images/1166_QC_CountPlot_ann.tiff",
       plot = count.plot, device = "tiff", type = "cairo",
       width = 8, height = 10, units = "in",
       dpi = 300, compression = "lzw")
ggsave(file = "/Users/ricardodgonzalez/Desktop/10X Genomics/April_14_2025/Analysis/1166/Images/1166_QC_vln.plot_ann.tiff",
      plot = vln.plot, device = "tiff", type = "cairo",
      width = 8, height = 10, units = "in",
     dpi = 300, compression = "lzw")
```



```{r}
# Create a data frame with cell barcodes and their annotation
annotation_df <- data.frame(
  Barcode = colnames(object),
  Annotation = object$full_first_type
)

# Save the annotation as a CSV file without row names
write.csv(
  annotation_df,
  file = "/Users/ricardodgonzalez/Desktop/10X Genomics/April_14_2025/Analysis/1166/Loupe/cell_annotations_for_loupe.csv",
  row.names = FALSE
)

```



Spatial autocorrelation (Moran's I) measures how similar or dissimilar expression values are among neighboring spatial locations. A high positive Moran's I for a gene means areas with high expression tend to be near other areas with high expression, indicating spatial clustering. A negative Moran’s I could mean spatial dispersion (checkerboard-like pattern).

The top Moran's I genes are "spatially variable genes" (SVGs) that capture the spatial heterogeneity of gene expression across your tissue or sample. They may highlight regions with distinct biological or cellular states.

These SVGs may serve as markers for spatial domains, cell types, or tissue structures because their expression is spatially patterned rather than uniform or random.
```{r}
library(Rfast2)
DefaultAssay(object) <- "Spatial.008um"
  object <- ScaleData(object, assay = "Spatial.008um")
object <- FindSpatiallyVariableFeatures(object,
                                       assay = "Spatial.008um",
                                       features = VariableFeatures(object)[1:1000],
                                       selection.method = "moransi",
                                       x.cuts = 100,
                                       y.cuts = 100)

# Extract Moran's I scores and related info
moransi_data <- SpatiallyVariableFeatures(object, selection.method = "moransi", verbose = FALSE)

 top_features <- head(SpatiallyVariableFeatures(object, method = "moransi"), 100)

 top_features <-as.data.frame(top_features)
# Save the annotation as a CSV file without row names
write.csv(
  top_features,
  file = "/Users/ricardodgonzalez/Desktop/10X Genomics/April_14_2025/Analysis/1166/moransi_top_features.csv",
  row.names = FALSE
)
# Proceed with plotting as before
a <- SpatialFeaturePlot(object,
                       features = head(SpatiallyVariableFeatures(object, selection.method = "moransi"), 25),
                       ncol = 5, alpha = c(0.1, 1), max.cutoff = "q95")
a
b <- SpatialFeaturePlot(object,
                       features = head(SpatiallyVariableFeatures(object, selection.method = "moransi"), 50),
                       ncol = 5, alpha = c(0.1, 1), max.cutoff = "q95")

c <- SpatialFeaturePlot(object,
                       features = head(SpatiallyVariableFeatures(object, selection.method = "moransi"), 10),
                       ncol = 5, alpha = c(0.1, 1), max.cutoff = "q95")
# Save TIFF plot
ggsave(file = "/Users/ricardodgonzalez/Desktop/10X Genomics/April_14_2025/Analysis/1166/Images/1166_Spatially_Variable_Features_10.tiff",
       plot = c, device = "tiff", type = "cairo",
       width = 20, height = 20, units = "in",
       dpi = 300, compression = "lzw")

```





```{r}
# single-cell analysis package
library(Seurat)

# plotting and data science packages
library(tidyverse)
library(cowplot)
library(patchwork)

# co-expression network analysis packages:
library(WGCNA)
library(hdWGCNA)

# enable parallel processing for network analysis (optional)
enableWGCNAThreads(nThreads = 8)

# using the cowplot theme for ggplot
theme_set(theme_cowplot())

# set random seed for reproducibility
set.seed(12345)
```



















#####################################################*Other*##################################################### 






```{r}
library(RColorBrewer)
library(scales)  # for alpha() if needed

# Get all identities in object
all_idents <- levels(Idents(object))

# Identities to assign distinct colors (excluding "Dying-cells")
idents_to_color <- setdiff(all_idents, "Dying-cells")

# Generate darker colors for other identities using Dark2 palette
# Make sure palette is large enough, else use colorRampPalette to extend
if (length(idents_to_color) <= 8) {
  colors_for_idents <- brewer.pal(length(idents_to_color), "Set1")
} else {
  # Extend palette if too many identities
  colors_for_idents <- colorRampPalette(brewer.pal(8, "Dark2"))(length(idents_to_color))
}

# Create named color vector including "Dying-cells" as gray
color_vector <- c(colors_for_idents, "Dying-cells" = "grey20")  # darker gray
names(color_vector) <- c(idents_to_color, "Dying-cells")

# Optional: make "Dying-cells" very transparent to further de-emphasize
#color_vector["Dying-cells"] <- alpha("grey20", 0.05)
#color_vector["Pericytes"] <- alpha("#89CFF0", 0.05)

# Plot with darker colors
DimPlot(object, cols = color_vector)
SpatialDimPlot(object, cols = color_vector)

#ggsave(file = "/Users/ricardodgonzalez/Desktop/10X Genomics/April_14_2025/Analysis/1166/1166_G3Annotated_UMAP.tiff",plot = d, device = "tiff", type = "cairo",width = 12, height = 10, units = "in",dpi = 300, compression = "lzw")
#ggsave(file = "/Users/ricardodgonzalez/Desktop/10X Genomics/April_14_2025/Analysis/1166/1166_G3Annotated_Spatial.tiff",plot = e, device = "tiff", type = "cairo",width = 12, height = 10, units = "in",dpi = 300, compression = "lzw")
```



```{r}
# Subset the Seurat object to exclude "Dying-cells"
object_no_dying <- subset(object, idents = "Dying-cells", invert = TRUE)

# Now plot using your existing color_vector but without "Dying-cells"
# Remember to remove "Dying-cells" from color vector as well
color_vector_no_dying <- color_vector[names(color_vector) != "Dying-cells"]

# Plot UMAP without Dying-cells
d_no_dying <- DimPlot(object_no_dying, cols = color_vector_no_dying)
# Plot SpatialDimPlot without Dying-cells
e_no_dying <- SpatialDimPlot(object_no_dying, cols = color_vector_no_dying)

# Display plots
d_no_dying
e_no_dying
#ggsave(file = "/Users/ricardodgonzalez/Desktop/10X Genomics/April_14_2025/Analysis/1166/1166_G3Annotated_UMAP_no_dying.tiff",plot = d_no_dying, device = "tiff", type = "cairo",width = 12, height = 10, units = "in",dpi = 300, compression = "lzw")
#ggsave(file = "/Users/ricardodgonzalez/Desktop/10X Genomics/April_14_2025/Analysis/1166/1166_G3Annotated_Spatial_no_dying.tiff",plot = e_no_dying, device = "tiff", type = "cairo",width = 12, height = 10, units = "in",dpi = 300, compression = "lzw")
```















#Visualize gene expression
Adjusting pt.size.factor (set to 1.2 by default) helps to visualize molecular and histological info in this HD dataset
You can also adjust the shape, and stroke (outline) parameters for visualization
```{r}
# switch spatial resolution to 16um from 8um

# switch back to 8um
DefaultAssay(object) <- "Spatial.008um"
p2 <- SpatialFeaturePlot(object, features = "PRTG") + ggtitle("PRTG expression (8um)")

p2
```




```{r}


data <- FetchData(object, vars = "PRTG")

percent_expressing_total <- 100 * sum(data$PRTG > 0) / nrow(data)

percent_expressing_total

```












